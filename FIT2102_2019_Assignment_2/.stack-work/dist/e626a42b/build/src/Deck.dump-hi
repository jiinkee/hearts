
==================== FINAL INTERFACE ====================
2019-10-04 09:13:41.6210008 UTC

interface hearts-0.1.0.0-HFI8OJwlE7V2tI6leOF0kf:Deck 8064
  interface hash: 0513969060acc1d2b31085103c8eb113
  ABI hash: 23711a8066c8e70426bc80abf058a8dc
  export-list hash: ae430ac1fdc7ca0e08179a21340e6e46
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8042b2e00b4bf5445e871ad940a72bd8
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Deck.deal
  Deck.shuffleList
  Deck.shuffledDeck
  Deck.sortedDeck
  Deck.Deck{Deck.Deck deck handSize}
module dependencies: Cards
package dependencies: Win32-2.6.1.0 array-0.5.3.0 base-4.12.0.0
                      deepseq-1.4.4.0 ghc-prim-0.5.3 integer-gmp-1.0.2.0 random-1.1
                      time-1.8.0.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Control.Monad be24c6211d7cb61f18d2854428d9a69e
import  -/  base-4.12.0.0:Data.Foldable 6673f41a7644ecd4dda455d741d47ef8
import  -/  base-4.12.0.0:Data.Functor 7be8e53dff1d6c612350c8ff6725f331
import  -/  base-4.12.0.0:Data.List ccb3c44b4e7df281b8508bfc1f389d8d
import  -/  base-4.12.0.0:Data.OldList cd51cf46346202f55e4ecde7f0f7b58e
import  -/  base-4.12.0.0:Data.Tuple ddbd97abaf9b62e84e82a5bae338d270
import  -/  base-4.12.0.0:GHC.Base 954f4c258d193fab7048a63bfeb56dcf
import  -/  base-4.12.0.0:GHC.List 63f1dc438c14c2ecfce50219fbb7ff35
import  -/  base-4.12.0.0:Prelude aea9afd24db8aed3563d7d850ea453c0
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  Cards d697d07d040dcb0fea10f2214ac7155e
  exports: cfa430ec5fd63670b639b890916903f0
  Card cfb951caaa2f9a5905caef5fecc70aec
  Card 19277cfa8f5abc322f41b6b66787ef36
  Spade 9610c4fcacda46bd9a47a11252efa895
  Two 29785d96ce03e730340e05c7753a8568
import  -/  random-1.1:System.Random 2df3d2176d852a42a0e8aa97126009b4
1a2b30e22bfa719a38fb3bab5507e714
  $sel:deck:Deck :: Deck.Deck -> [Cards.Card]
  RecSel Left Deck.Deck
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Deck.Deck) ->
                 case ds of wild { Deck.Deck ds1 ds2 -> ds2 }) -}
1a2b30e22bfa719a38fb3bab5507e714
  $sel:handSize:Deck :: Deck.Deck -> GHC.Types.Int
  RecSel Left Deck.Deck
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Deck.Deck) ->
                 case ds of wild { Deck.Deck ds1 ds2 -> ds1 }) -}
d115186034d499f1b828c5b06b8c0b6a
  $tc'Deck :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17701834991208265436##
                   17404226705769368783##
                   Deck.$trModule
                   Deck.$tc'Deck2
                   0#
                   Deck.$tc'Deck1) -}
2ba9b9a71369ac235ddb853275b46c47
  $tc'Deck1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
54d848034b59fff41f3a50c32f964933
  $tc'Deck2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Deck.$tc'Deck3) -}
0d488ce4b57f663e6c9e29c7e27a7168
  $tc'Deck3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Deck"#) -}
cdaf996fa155d615043772ae689729f6
  $tcDeck :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9246640770232009006##
                   2506255553286559120##
                   Deck.$trModule
                   Deck.$trModule1
                   0#
                   GHC.Types.krep$*) -}
79461c4f1b651b85c38401790a715c39
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Deck.$trModule3 Deck.$trModule1) -}
42864c5ed171ae8353ed44779eb7dfe3
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Deck.$trModule2) -}
d74f0cd65809815ae51590624ef4c6f1
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Deck"#) -}
6bbe2d0a480052e0526f9bfaa7eec2fe
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Deck.$trModule4) -}
c670445b5fca2e3d8e0523daacf3635b
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("hearts-0.1.0.0-HFI8OJwlE7V2tI6leOF0kf"#) -}
43e42e56e45ebac3325260b666fb9418
  $wdeal ::
    GHC.Types.Int -> GHC.Prim.Int# -> [Cards.Card] -> [[Cards.Card]]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U)><S,U><L,U>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Types.Int)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: [Cards.Card]) ->
                 case GHC.Prim.<# 0# ww of lwild {
                   DEFAULT -> GHC.Types.[] @ [Cards.Card]
                   1#
                   -> letrec {
                        $wgo2 :: [Cards.Card] -> GHC.Prim.Int# -> [[Cards.Card]]
                          {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [2] -}
                        = \ (w2 :: [Cards.Card]) (ww1 :: GHC.Prim.Int#) ->
                          let {
                            x :: [Cards.Card]
                            = case w of wild1 { GHC.Types.I# y ->
                              case GHC.Prim.<# 0# y of lwild1 {
                                DEFAULT -> GHC.Types.[] @ Cards.Card
                                1# -> GHC.List.$wunsafeTake @ Cards.Card y w2 } }
                          } in
                          case ww1 of ds1 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ [Cards.Card]
                                 x
                                 ($wgo2 (GHC.List.drop @ Cards.Card w w2) (GHC.Prim.-# ds1 1#))
                            1# -> GHC.Types.: @ [Cards.Card] x (GHC.Types.[] @ [Cards.Card]) }
                      } in
                      $wgo2 w1 ww }) -}
4b3d1db300464e393e09480373ae80bd
  $wloop ::
    GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Int] #)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2] -}
1a2b30e22bfa719a38fb3bab5507e714
  data Deck = Deck {handSize :: GHC.Types.Int, deck :: [Cards.Card]}
eadeb61db747bbd08138507b83db6cc3
  deal ::
    GHC.Types.Int -> GHC.Types.Int -> [Cards.Card] -> [[Cards.Card]]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U)><S(S),1*U(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [Cards.Card]) ->
                 case w1 of ww { GHC.Types.I# ww1 -> Deck.$wdeal w ww1 w2 }) -}
02261cada89e0f4a259fcf46bda5ea06
  shuffleList :: [a] -> GHC.Types.IO [a]
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Deck.shuffleList1
                  `cast`
                (forall (a :: <*>_N).
                 <[a]>_R ->_R Sym (GHC.Types.N:IO[0] <[a]>_R)) -}
7a57bd7b91c74ff3c7ed7d62bc01b7da
  shuffleList1 ::
    [a]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ @ a
                   (l :: [a])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.List.$wlenAcc @ a l 0# of ww2 { DEFAULT ->
                 case Deck.$wloop ww2 s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    GHC.Base.map
                      @ (GHC.Types.Int, (GHC.Types.Int, a))
                      @ a
                      (Deck.shuffleList4 @ a)
                      (Data.OldList.sortBy
                         @ (GHC.Types.Int, (GHC.Types.Int, a))
                         (Deck.shuffleList3 @ a)
                         (Deck.shuffleList2 @ a ipv1 l)) #) } }) -}
9cf10aabb077ee3f3a67525e94e44982
  shuffleList2 ::
    [GHC.Types.Int] -> [a] -> [(GHC.Types.Int, (GHC.Types.Int, a))]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
6f389da8b38ff905999dd874ba8f9f57
  shuffleList3 ::
    (GHC.Types.Int, (GHC.Types.Int, a))
    -> (GHC.Types.Int, (GHC.Types.Int, a)) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),A)><S(S(S)L),1*U(1*U(U),A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (x :: (GHC.Types.Int, (GHC.Types.Int, a)))
                   (y :: (GHC.Types.Int, (GHC.Types.Int, a)))[OneShot] ->
                 case x of wild { (,) x1 ds1 ->
                 case x1 of wild1 { GHC.Types.I# x# ->
                 case y of wild2 { (,) x2 ds2 ->
                 case x2 of wild3 { GHC.Types.I# y# ->
                 GHC.Classes.compareInt# x# y# } } } }) -}
bfcbf84772f9f76efe6ad6785c38a409
  shuffleList4 :: (GHC.Types.Int, (GHC.Types.Int, a)) -> a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LS)),1*U(A,1*U(A,1*U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: (GHC.Types.Int, (GHC.Types.Int, a))) ->
                 case x of wild { (,) ds1 y ->
                 case y of wild1 { (,) ds2 y1 -> y1 } }) -}
d0aea6c7d44ca21e0e48013cd92a0f88
  shuffledDeck :: GHC.Types.IO [Cards.Card]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Deck.shuffledDeck1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <[Cards.Card]>_R)) -}
c853099602cc6b4342a8578afd30cf8c
  shuffledDeck1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [Cards.Card] #)
  {- Arity: 1,
     Unfolding: (Deck.shuffleList1 @ Cards.Card Deck.sortedDeck) -}
e6b265f30bb0f5dfde86ffa72f8f8397
  sortedDeck :: [Cards.Card]
  {- Unfolding: (Deck.sortedDeck_go Cards.$fEnumSuit4) -}
db69889d1d8e3c3637608429f60ac9ae
  sortedDeck_go :: [Cards.Suit] -> [Cards.Card]
  {- Arity: 1, Strictness: <S,1*U> -}
trusted: trustworthy
require own pkg trusted: True
module header:
  Nothing
declaration docs:
arg docs:

